import fs from "node:fs";
import { cwd } from "node:process";

import { Position, Stroke, TegakiStroke } from "@tegaki/shared";
import { defineCommand } from "citty";
import consola from "consola";
import { XMLParser } from "fast-xml-parser";

export const datagen = defineCommand({
  meta: {
    name: "datagen",
    description: "generate data from xml stroke data",
  },
  args: {
    dataDir: {
      description: "data directory",
      type: "string",
      alias: "d",
      default: cwd() + "/tegaki_data",
    },
    out: {
      description: "output path with filename",
      type: "string",
      alias: "o",
      default: cwd() + "/tegaki_data/data",
    },
    exportName: {
      description: "export name",
      type: "string",
      alias: "n",
      default: "TEGAKI_DATA_SET",
    },
    ts: {
      description: "use typescript",
      type: "boolean",
      default: true,
    },
    cjs: {
      description: "use commonjs. if ts option is true, this option is ignored",
      type: "boolean",
      default: false,
    },
  },
  run: async ({ args }) => {
    try {
      const { out, ts, cjs, exportName, dataDir } = args;
      const paths = getPaths(dataDir);
      const xmls = paths.filter(path => path.endsWith(".xml"));
      const parsed = xmls.map(xml => parse(fs.readFileSync(xml, "utf-8")));
      const code = codegen(parsed, { ts, cjs, exportName });
      fs.mkdirSync(out.split("/").slice(0, -1).join("/"), { recursive: true });
      fs.writeFileSync(`${out}`, code);
    } catch (e) {
      consola.error(e);
      process.exit(1);
    }
  },
});

type CodegenOptions = { ts: boolean; cjs: boolean; exportName: string };
const codegen = (parsed: TegakiStroke[], { ts, cjs, exportName }: CodegenOptions): string => {
  const code = `/// This file is generated by tegaki-cli. Do not edit this file directly
${ts ? 'import type { TegakiStroke } from "@tegaki/shared";' : ""}
${cjs ? `module.exports.${exportName}` : `export const ${exportName}`}${
    ts ? ": Array<TegakiStroke>" : ""
  } = ${JSON.stringify(parsed)};
`;
  return code;
};

type XML = {
  kanji: {
    unicode: string;
    stroke: Array<{ point: Array<{ "@_x": string; "@_y": string }> }>;
  };
};

const parse = (xml: string): TegakiStroke => {
  const parser = new XMLParser({ ignoreAttributes: false });
  const jsonObj = parser.parse(xml) as XML;
  const { kanji } = jsonObj;
  const { unicode, stroke } = kanji;
  const tuple_d = stroke.map(({ point }) => point.map((it): Position => [Number(it["@_x"]), Number(it["@_y"])]));
  return [unicode, tuple_d.length, tuple_d];
};

const getPaths = (dir: string): string[] =>
  fs
    .readdirSync(dir, { withFileTypes: true })
    .flatMap(dirent => (dirent.isFile() ? [`${dir}/${dirent.name}`] : getPaths(`${dir}/${dirent.name}`)));
